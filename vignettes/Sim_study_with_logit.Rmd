---
title: "Simulation study with logit"
author: "Benjamin Christoffersen"
date: "11 November 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup
```{r}
ns <- 2*10^(2:3)
n_beta <- 5
T_max <- 10
n_sims <- 100

gsub("(^.+)(/dynamichazard.+$)", "...\\2", getwd())
source("../R./test_utils.R")
ls() # we need the test_ functions
```

## Estimating from true model

```{r est_true_setup}
set.seed(20161109)

# Default arguments for simulation
default_args <- list(
  n_vars = n_beta, # Number of betas not including intercept
  beta_start = c(-1, -.5, 0, 1.5, 2), # start value of coeffecients
  intercept_start = -4, # start value of intercept
  sds = c(.1, rep(1, n_beta)), # std. deviation in state equation
  t_max = T_max, # Large time we observe
  x_range = 1, # range of covariates
  x_mean = .5) # mean of covariates)

# We get a decent amount of failures
# We use do.call to avoid repeating the above argument list
# See ?do.call
n_fails_in_sim <- rep(NA_real_, 15)
for(i in seq_along(n_fails_in_sim)){
  sims <- do.call(test_sim_func_logit, c(
    default_args, c(list(n_series = max(ns))))) # Take largest amount of series
  n_fails_in_sim[i] <- sum(sims$res$event)
}
n_fails_in_sim

# We can simulate by
sims <- do.call(test_sim_func_logit, c(list(n_series = max(ns)), default_args))

# This is how the state vectors look
(plot_func <- function(ylim = c()) # we define a function here so we can use it later
  matplot(sims$betas, type = "l", lty = 1, ylab = "time", xlab = "beta",
          ylim = range(sims$betas, ylim), col = 1:(n_beta + 1)))()
```

```{r est_true_fit_funcs_static}
library(survival); library(dynamichazard)

# Set up function for static fit
fit_funcs = list()
fit_funcs$static <- function(s = sims$res)
  static_glm(formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
             data = s, max_T = T_max, by = 1, id = s$id) 

fit <- fit_funcs$static()
class(fit) # returns a glm object

# Estimates match simulations
plot_func(ylim = fit$coefficients)
abline(h = fit$coefficients, col = 1:(n_beta + 1), lty = 2)
```

```{r est_true_fit_ddhazrd_out_of_box}
library(survival); library(dynamichazard)

# Set up function ddhazard fit function for convenience
# LR:       learning rate in correction step
# NR_eps:   tolerance in correction step. NULL yields no extra loops
fit_funcs$dd <- function(s = sims$res, LR = 1, NR_eps = NULL)
  tryCatch({
    ddhazard(formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
             data = s, max_T = T_max, by = 1, id = s$id, 
             Q_0 = diag(1, n_beta + 1), Q = diag(.01, n_beta + 1),
             control = list(LR = LR, NR_eps = NR_eps))
  }, error = function(...) NA) # Return NA if fails

tmp <- file("tmp.txt")
sink(tmp)
fit <- fit_funcs$dd(LR = .75)
sink()
close(tmp)

# Estimates match simulations
plot_func(ylim = fit$state_vecs)
matplot(fit$state_vecs, col = 1:(n_beta + 1), lty = 2, 
        type = "l", add = T)

# Same call with extra iterations
fit <- fit_funcs$dd(LR = .75, NR_eps = .01)

# Look at new plot
plot_func(ylim = fit$state_vecs)
matplot(fit$state_vecs, col = 1:(n_beta + 1), lty = 2, 
        type = "l", add = T)

# Fitting with UKF
fit_funcs$dd_UKF <- function(s = sims$res){
  tryCatch({
    ddhazard(formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
             data = s, max_T = T_max, by = 1, id = s$id, 
             Q_0 = diag(1, n_beta + 1), Q = diag(.01, n_beta + 1),
             control = list(alpha = .5, beta = 0, method = "UKF"))
  }, error = function(...) NA) # Return NA if fails
}

fit <- fit_funcs$dd_UKF()

# Look at new plot
plot_func(ylim = fit$state_vecs)
matplot(fit$state_vecs, col = 1:(n_beta + 1), lty = 2, 
        type = "l", add = T)
```

```{r est_true_fit_mgcv}
library(mgcv)
fit_funcs$gam <- function(s = sims$res){
  # get data frame for fitting
  dat_frame <- get_survival_case_weigths_and_data(
    formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
               data = s, max_T = T_max, by = 1, id = s$id, use_weights = F)
  # fit model
  gam(
    formula = Y ~ 
      # cr is cubic basis with dim of k
      s(t, bs = "cr", k = 10, by = x1) + 
      s(t, bs = "cr", k = 10, by = x2) + 
      s(t, bs = "cr", k = 10, by = x3) + 
      s(t, bs = "cr", k = 10, by = x4) + 
      s(t, bs = "cr", k = 10, by = x5),
  family = binomial, data = dat_frame,
  method = "GCV.Cp")
}

# fit model
fit <- fit_funcs$gam()

# Compare plot
layout(matrix(1:6, nrow = 2))
for(i in 1:n_beta){
  plot(fit, pages = 0, rug = F, col = i + 1, select = i, lty = 2)
  lines(sims$betas[-1, i + 1], col = i + 1)
}
```

```{r est_true_pred_funcs_static}
split_func <- function(s = sims$res){
  # Sample ids
  test_ids <- sample(
    unique(s$id), floor(length(unique(s$id)) / 2), replace = F) 
  
  # Return seperate data frames
  return(list(test_dat = s[s$id %in% test_ids, ],
              fit_dat = s[!s$id %in% test_ids, ]))
}

# Illustrate use
tmp <- split_func()
length(intersect(tmp$test_dat$id, tmp$fit_dat$id))
length(union(tmp$test_dat$id, tmp$fit_dat$id))

# Define prediction function for static model
brier_funcs <- list() 
brier_funcs$general <- function(brier_func, fit, eval_data_frame){
  d_frame <- get_survival_case_weigths_and_data(
    formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
                   data = eval_data_frame, max_T = T_max, by = 1, id = eval_data_frame$id, 
    use_weights = F)
  d_frame$tstart <- d_frame$t - 1
  d_frame$tstop <- d_frame$t
  
  res <- brier_func(fit, d_frame)
  list(brier = res$brier,
       median_abs_res = res$median_abs_res,
       info = cbind(resids = res$resids,
                    tstop = d_frame$tstop, 
                    id = d_frame$id))
}

brier_funcs$static <- function(fit, d_frame){
  # Find predicted probablities and return Brier score
  preds <- predict(fit, newdata = d_frame, type = "response")
  resids <- d_frame$Y - preds

  list(brier = mean.default(resids^2),
       median_abs_res = median(abs(resids)),
       resids = resids)
}

# Test function
fit <- fit_funcs$static(tmp$fit_dat)
brier_funcs$general(brier_funcs$static, fit, tmp$fit_dat)[
  c("brier", "median_abs_res")] # in sample stats
brier_funcs$general(brier_funcs$static, fit, tmp$test_dat)[
  c("brier", "median_abs_res")] # out sample stats
```

```{r est_true_pred_ddhazard}
# Define prediction function for ddhazard model
brier_funcs$dd <- function(fit, d_frame){
  suppressMessages(preds <- predict(fit, new_data = d_frame, tstart = "tstart", tstop = "tstop"))
  resids <- d_frame$Y - preds$fits

  list(brier = mean.default(resids^2), 
       median_abs_res = median(abs(resids)),
       resids =  resids)
}

fit <- fit_funcs$dd(tmp$fit_dat, LR = .75)
brier_funcs$general(brier_funcs$dd, fit, tmp$fit_dat)[
  c("brier", "median_abs_res")] # in sample stats
brier_funcs$general(brier_funcs$dd, fit, tmp$test_dat)[
  c("brier", "median_abs_res")] # out sample stats

fit <- fit_funcs$dd(tmp$fit_dat, LR = .75, NR_eps = .01)
brier_funcs$general(brier_funcs$dd, fit, tmp$fit_dat)[
  c("brier", "median_abs_res")] # in sample stats
brier_funcs$general(brier_funcs$dd, fit, tmp$test_dat)[
  c("brier", "median_abs_res")] # in sample stats
```

```{r est_true_pred_gam}
# Define prediction function for gam model
brier_funcs$gam <- function(fit, d_frame){
  preds <- predict(fit, newdata = d_frame, type = "response")
  resids <- d_frame$Y - preds

  list(brier = mean.default(resids^2), 
       median_abs_res = median(abs(resids)),
       resids =  resids)
}

fit <- fit_funcs$gam(tmp$fit_dat)
brier_funcs$general(brier_funcs$gam, fit, tmp$fit_dat)[
  c("brier", "median_abs_res")] # in sample stats
brier_funcs$general(brier_funcs$gam, fit, tmp$test_dat)[
  c("brier", "median_abs_res")] # out sample stats
```

```{r simulations}
n <- ns[2]
LRs <- c(.1, .5, 1, .5, 1)
NR_eps <- c(rep(.01, 3), NA, NA)

out <- matrix(NA_real_, nrow = n_sims, ncol = 6 + length(LRs) * 2,
              dimnames = list(
                NULL,
                c(outer(
                  c("static", paste("dd (", LRs, ", ", NR_eps, ")", sep = ""), 
                    "UKF", "gam"), 
                  c("Brier", "Median abs res"), paste))))

for(i in 1:n_sims){
  # Sample until we have suffecient amount of deaths and failures
  repeat{
    sims <- do.call(test_sim_func_logit,
                    c(default_args, c(list(n_series = n))))
    
    # We want some failurse and some deaths
    if(sum(sims$res$event) > 50 && n - sum(sims$res$event) > 50)
      break
  }
  
  # Split data
  sim_split <- split_func(sims$res)
  
  # Fit static model
  static_fit <- fit_funcs$static(sim_split$fit_dat)
  
  # Fit dd model
  dd_fits <- list(rep(NA, length(LRs)))
  for(k in seq_along(LRs)){
    suppressMessages(
      dd_fits[[k]] <- fit_funcs$dd(sim_split$fit_dat, LR = LRs[k], 
                                   NR_eps = if(is.na(NR_eps[k])) NULL else NR_eps[k]))
  }
  
  # UKF fit 
  suppressMessages(dd_UKF <- fit_funcs$dd_UKF(sim_split$fit_dat))
  
  # Fit gam model
  gam_fit <- fit_funcs$gam(sim_split$fit_dat)
  
  # Evalute on test data
  models <- c(list(static_fit), dd_fits, list(dd_UKF), list(gam_fit))
  
  eval_funcs = c(brier_funcs$static,
                 replicate(length(dd_fits) + 1, brier_funcs$dd),
                 brier_funcs$gam)
                 
  for(j in seq_along(models)){
    if(length(models[[j]]) == 1 && is.na(models[[j]]))
      next
    metrics <- brier_funcs$general(
      eval_funcs[[j]], models[[j]], sim_split$test_dat)
    out[i, j] <- metrics$brier
    out[i, j + length(models)] <- metrics$median_abs_res
  }
  
  print(out[1:i, ], digits = 4)
}

print(out, digits = 3)

colMeans(out[complete.cases(out), ])

```
