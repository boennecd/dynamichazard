---
title: "Simulation study with logit"
author: "Benjamin Christoffersen"
date: "11 November 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup
```{r}
ns <- 2*10^(2:3)
n_beta <- 5
T_max <- 10

gsub("(^.+)(/dynamichazard.+$)", "...\\2", getwd())
source("../R./test_utils.R")
ls() # we need the test_ functions
```

## Estimating from true model

```{r est_true_setup}
set.seed(20161109)

# Default arguments for simulation
default_args <- list(
  n_vars = n_beta, # Number of betas not including intercept
  beta_start = rnorm(n_beta, mean = 1), # start value of coeffecients
  intercept_start = -5, # start value of intercept
  sds = c(.1, rep(.5, n_beta)), # std. deviation in state equation
  t_max = T_max, # Large time we observe
  x_range = 2, # range of covariates
  x_mean = 0) # mean of covariates)

# We get a decent amount of failures
# We use do.call to avoid repeating the above argument list
# See ?do.call
n_fails_in_sim <- rep(NA_real_, 15)
for(i in seq_along(n_fails_in_sim)){
  sims <- do.call(test_sim_func_logit, c(
    default_args, c(list(n_series = max(ns))))) # Take largest amount of series
  n_fails_in_sim[i] <- sum(sims$res$event)
}
n_fails_in_sim

# We can simulate by
sims <- do.call(test_sim_func_logit, c(list(n_series = max(ns)), default_args))

# Have to adjust the stop time to T_max
# First we illustrate that this why this is ok
all(!(sims$res[, "event"] == 1 &
        sims$res$tstop > T_max)) # no one dies after T_max
all(sims$res$tstart < T_max) # no one starts after T_max

# Thus, we can truncate
sims$res$tstop <- pmax(sims$res$tstop, T_max)

# This is how the state vectors look
(plot_func <- function(ylim = c()) # we define a function here so we can use it later
  matplot(sims$betas, type = "l", lty = 1, ylab = "time", xlab = "beta",
          ylim = range(sims$betas, ylim), col = 1:(n_beta + 1)))()
```

```{r est_true_fit_funcs_static}
library(survival); library(dynamichazard)

# Set up function for static fit
fit_funcs = list()
fit_funcs$static <- function(s = sims$res)
  static_glm(formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
             data = s, max_T = T_max, by = 1, id = s$id) 

fit <- fit_funcs$static()
class(fit) # returns a glm object

# Estimates match simulations
plot_func(ylim = fit$coefficients)
abline(h = fit$coefficients, col = 1:(n_beta + 1), lty = 2)
```

```{r est_true_fit_ddhazrd_out_of_box}
library(survival); library(dynamichazard)

# Set up function ddhazard fit function for convenience
# LR:       learning rate in correction step
# NR_eps:   tolerance in correction step. NULL yields no extra loops
fit_funcs$dd <- function(s = sims$res, LR = 1, NR_eps = NULL)
  tryCatch({
    ddhazard(formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
             data = s, max_T = T_max, by = 1, id = s$id, 
             control = list(LR = LR, NR_eps = NR_eps))
  }, error = function(...) NA) # Return NA if fails

fit <- fit_funcs$dd()

# Estimates match simulations
plot_func(ylim = fit$state_vecs)
matplot(fit$state_vecs, col = 1:(n_beta + 1), lty = 2, 
        type = "l", add = T)

# Same call with extra iterations
fit <- fit_funcs$dd(LR = .5, NR_eps = 0.1)

# Look at new plot
plot_func(ylim = fit$state_vecs)
matplot(fit$state_vecs, col = 1:(n_beta + 1), lty = 2, 
        type = "l", add = T)
```

```{r est_true_fit_mgcv}
library(mgcv)
fit_funcs$gam <- function(s = sims$res){
  # get data frame for fitting
  dat_frame <- get_survival_case_weigths_and_data(
    formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
               data = s, max_T = T_max, by = 1, id = s$id, use_weights = F)
  # fit model
  gam(
    formula = Y ~ 
      # cr is cubic basis with dim of k
      s(t, bs = "cr", k = 5, by = x1) + 
      s(t, bs = "cr", k = 5, by = x2) + 
      s(t, bs = "cr", k = 5, by = x3) + 
      s(t, bs = "cr", k = 5, by = x4) + 
      s(t, bs = "cr", k = 5, by = x5),
  family = binomial, data = dat_frame,
  method = "GCV.Cp")
}

# fit model
fit <- fit_funcs$gam()

# Compare plot
layout(matrix(1:6, nrow = 2))
for(i in 1:n_beta)
  plot(fit, pages = 0, rug = F, col = i + 1, select = i)
```

```{r est_true_pred_funcs_static}
split_func <- function(s = sims$res){
  # Sample ids
  test_ids <- sample(
    unique(s$id), floor(length(unique(s$id)) / 2), replace = F) 
  
  # Return seperate data frames
  return(list(test_dat = s[s$id %in% test_ids, ],
              fit_dat = s[!s$id %in% test_ids, ]))
}

# Illustrate use
tmp <- split_func()
length(intersect(tmp$test_dat$id, tmp$fit_dat$id))
length(union(tmp$test_dat$id, tmp$fit_dat$id))

# Define prediction function for static model
fit <- fit_funcs$static(tmp$fit_dat)

brier_funcs <- list() 
brier_funcs$static <- function(fit, d_frame){
  # Find people who dies
  do_die <- tapply(d_frame$event, d_frame$id, sum)
  
  # Find data frame for prediction
  d_frame <- get_survival_case_weigths_and_data(
    formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
                   data = d_frame, max_T = T_max, by = 1, id = d_frame$id, 
    use_weights = F)
  
  # Find predicted probablities and return Brier score
  preds <- predict(fit, newdata = d_frame, type = "response")
  preds <- 1 - tapply(preds, d_frame$id, function(x) prod(1 - x))

  mean.default((do_die - preds)^2)
}

brier_funcs$static(fit, tmp$fit_dat) # in sample brier score
brier_funcs$static(fit, tmp$test_dat) # out sample brier score
```

```{r est_true_pred_ddhazard}
# Define prediction function for static model
fit <- fit_funcs$dd(tmp$fit_dat)

d_frame <- tmp$test_dat

d_frame$tstop <- pmax(d_frame$tstop, T_max) # Have to adjust due to definition 
                                            # of predict function

do_die <- tapply(d_frame$event, d_frame$id, sum)

preds <- predict(fit, new_data = d_frame, tstart = "tstart", tstop = "tstop")
preds <- 1 - tapply(preds$fits, d_frame$id, function(x) prod(1 - x))

mean.default((preds - do_die)^2)

brier_funcs <- list() 
brier_funcs$dd <- function(fit, d_frame){
  # Find data frame for prediction
  d_frame <- get_survival_case_weigths_and_data(
    formula = Surv(tstart, tstop, event) ~ . - tstart - tstop - id - event,
                   data = d_frame, max_T = T_max, by = 1, id = d_frame$id, 
    use_weights = F)
  
  # Find predicted probablities and return Brier score
  preds <- predict(fit, newdata = d_frame, type = "response")
  mean.default((d_frame$Y - preds)^2)
}

brier_funcs$static(fit, tmp$fit_dat) # in sample brier score
brier_funcs$static(fit, tmp$test_dat) # out sample brier score
```
