---
title: "Comparing UKF implementations"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

  ## Set the width of the R-terminal to # characters
  options(width = 80, warn = -1)

# Derfine function to make small margin in pictures
# you can use the bool flag to set what to excute before, after chunk 
# or always
# If you do not whant to excute the code than do e.g. small.mar = F
knitr::knit_hooks$set(small.mar = function(before, options, envir){
  if (before){ par(
    mar = c(5,5,0.5,0.5), 
    tcl = -0.3, 
    mgp = c(2.5,.5,0), 
    oma = c(0,0,0,0),
    pch=16,
    cex=.6,
    cex.axis = 1,
    cex.lab = .8/.6,
    lwd= 1
  )}},
  my.options=function(before, options, envir){
    if(before){
      options(digits = 3)
    }})

## opts_chunk$set() can change the default global options in a document (e.g. put this in a code chunk
knitr::opts_chunk$set(fig.path='figures/',
               fig.align='center',
               fig.width=6, fig.height=4,
               out.width="0.7\\textwidth",
               size='tiny',                ## See R highligt package for possible values (https://cran.r-project.org/web/packages/highlight/highlight.pdf)
               small.mar = TRUE,
               my.options = TRUE,
               comment = "##", 
               warnings = T,
               errors = T
)
```

## Simulating
We will start by simulating data with the following function (you can skip the definition of the simulation code)

```{r}
# We are currenlty in the vignettes folder
getwd()
source("../R./test_utils.R")
test_sim_func_logit
```

Our simulations arguments are

```{r}
sim_args <- list(
  n_series = 5e2, # <-- number of individuals we simulate
  n_vars = 3, # <-- number of co-variates (not including the intercept)
  t_0 = 0, t_max = 10, x_range = 1, x_mean = -.5, re_draw = T,
  beta_start = 1, intercept_start = -1, sds = c(.1, rep(1, 3)))
```

The final data set has the following number of events

```{r}
set.seed(2972)
sims <- do.call(test_sim_func_logit, sim_args)
sum(sims$res$event) # number of individuals who dies
```

## Computation time

How much faster is the new method compared with the orginal formulation and the EKF? First we define the call parameters for `ddhazard`: 
```{r}
dd_args <- list(
  formula = survival::Surv(tstart, tstop, event) ~ . - tstart - tstop - event - id,
  by = 1, data = sims$res,
  a_0 = rep(0, ncol(sims$res) + 1 - 4), # set starting values for parems to zero
  Q_0 = diag(rep(1, ncol(sims$res) + 1 - 4)),
  est_Q_0 = F, # <-- fixed Q_0 variance 
  method = "UKF", # <-- use the new method
  kappa = 0, # <-- set kappa to zero in UKF to avoid issues with non-postive 
             #     definite variance matrix
  verbose = F, eps = 1e-2,
  id = sims$res$id,
  max_T = 10)

dd_args_UKF_org <- dd_args
dd_args_UKF_org$method <- "UKF_org" # yields orginal formulation of UKF

dd_args_EKF <- dd_args
dd_args_EKF$method <- "EKF" # <-- yields EKF
```

We can compare the computation time using `microbenchmark`

```{r}
bench_res <- microbenchmark::microbenchmark(
  do.call(dynamichazard::ddhazard, dd_args),         # <-- new method
  do.call(dynamichazard::ddhazard, dd_args_UKF_org), # <-- orginal method
  do.call(dynamichazard::ddhazard, dd_args_EKF),     # <-- EKF
  times = 10)

attr(summary(bench_res), "unit") # <-- the time scale reported below
summary(bench_res)[c("expr", "min","mean", "median", "max")]
```

(I have to look into the EKF. It may be slower due to the parallel implementation and only a "few" cases here)

## Does it give the same result
Yes
```{r}
fit_new <- do.call(dynamichazard::ddhazard, dd_args)
fit_org <- do.call(dynamichazard::ddhazard, dd_args_UKF_org)

all.equal(fit_new$a_t_d_s, fit_org$a_t_d_s)
all.equal(fit_new$V_t_d_s, fit_org$V_t_d_s)
all.equal(fit_new$Q, fit_org$Q)
```

## Does it scale linearly in observational equation
Yes

```{r}
run_time_func <- function(n){
  set.seed(2972)
  sim_args$n_series <- n
  sims <- do.call(test_sim_func_logit, sim_args)
  
  dd_args_local <- dd_args
  dd_args_local$data <- sims$res
  dd_args_local$id <- sims$res$id
  
  system.time(do.call(dynamichazard::ddhazard, dd_args_local))
}

n_for_test <- 2^(8:15)
run_time <- sapply(n_for_test, run_time_func)

plot(n_for_test, run_time["user.self", ], type = "p", log = "xy", 
     xlab = "n", ylab = "computation time") 

coef(lm(log(run_time["user.self", ]) ~ log(n_for_test)))
```
